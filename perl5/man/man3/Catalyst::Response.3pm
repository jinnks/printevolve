.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::Response 3pm"
.TH Catalyst::Response 3pm "2020-07-26" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Response \- stores output responding to the current client request
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    $res = $c\->response;
\&    $res\->body;
\&    $res\->code;
\&    $res\->content_encoding;
\&    $res\->content_length;
\&    $res\->content_type;
\&    $res\->cookies;
\&    $res\->header;
\&    $res\->headers;
\&    $res\->output;
\&    $res\->redirect;
\&    $res\->status;
\&    $res\->write;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the Catalyst Response class, which provides methods for responding to
the current client request. The appropriate Catalyst::Engine for your environment
will turn the Catalyst::Response into a \s-1HTTP\s0 Response and return it to the client.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$res\->body( $text | $fh | $iohandle_object )"
.el .SS "\f(CW$res\fP\->body( \f(CW$text\fP | \f(CW$fh\fP | \f(CW$iohandle_object\fP )"
.IX Subsection "$res->body( $text | $fh | $iohandle_object )"
.Vb 1
\&    $c\->response\->body(\*(AqCatalyst rocks!\*(Aq);
.Ve
.PP
Sets or returns the output (text or binary data). If you are returning a large body,
you might want to use a IO::Handle type of object (Something that implements the getline method
in the same fashion), or a filehandle \s-1GLOB.\s0 These will be passed down to the \s-1PSGI\s0
handler you are using and might be optimized using server specific abilities (for
example Twiggy will attempt to server a real local file in a non blocking manner).
.PP
If you are using a filehandle as the body response you are responsible for
making sure it conforms to the \s-1PSGI\s0 specification with regards to content
encoding.  Unlike with scalar body values or when using the streaming interfaces
we currently do not attempt to normalize and encode your filehandle.  In general
this means you should be sure to be sending bytes not \s-1UTF8\s0 decoded multibyte
characters.
.PP
Most of the time when you do:
.PP
.Vb 1
\&    open(my $fh, \*(Aq<:raw\*(Aq, $path);
.Ve
.PP
You should be fine.  If you open a filehandle with a PerlIO layer you probably
are not fine.  You can usually fix this by explicitly using binmode to set
the IOLayer to :raw.  Its possible future versions of Catalyst will try to
\&'do the right thing'.
.PP
When using a IO::Handle type of object and no content length has been
already set in the response headers Catalyst will make a reasonable attempt
to determine the size of the Handle. Depending on the implementation of your
handle object, setting the content length may fail. If it is at all possible
for you to determine the content length of your handle object,
it is recommended that you set the content length in the response headers
yourself, which will be respected and sent by Catalyst in the response.
.PP
Please note that the object needs to implement \f(CW\*(C`getline\*(C'\fR, not just
\&\f(CW\*(C`read\*(C'\fR.  Older versions of Catalyst expected your filehandle like objects
to do read.  If you have code written for this expectation and you cannot
change the code to meet the \s-1PSGI\s0 specification, you can try the following
middleware Plack::Middleware::AdaptFilehandleRead which will attempt to
wrap your object in an interface that so conforms.
.PP
Starting from version 5.90060, when using an IO::Handle object, you
may want to use Plack::Middleware::XSendfile, to delegate the
actual serving to the frontend server. To do so, you need to pass to
\&\f(CW\*(C`body\*(C'\fR an \s-1IO\s0 object with a \f(CW\*(C`path\*(C'\fR method. This can be achieved in
two ways.
.PP
Either using Plack::Util:
.PP
.Vb 2
\&  my $fh = IO::File\->new($file, \*(Aqr\*(Aq);
\&  Plack::Util::set_io_path($fh, $file);
.Ve
.PP
Or using IO::File::WithPath
.PP
.Vb 1
\&  my $fh = IO::File::WithPath\->new($file, \*(Aqr\*(Aq);
.Ve
.PP
And then passing the filehandle to body and setting headers, if needed.
.PP
.Vb 4
\&  $c\->response\->body($fh);
\&  $c\->response\->headers\->content_type(\*(Aqtext/plain\*(Aq);
\&  $c\->response\->headers\->content_length(\-s $file);
\&  $c\->response\->headers\->last_modified((stat($file))[9]);
.Ve
.PP
Plack::Middleware::XSendfile can be loaded in the application so:
.PP
.Vb 6
\& _\|_PACKAGE_\|_\->config(
\&     psgi_middleware => [
\&         \*(AqXSendfile\*(Aq,
\&         # other middlewares here...
\&        ],
\& );
.Ve
.PP
\&\fBBeware\fR that loading the middleware without configuring the
webserver to set the request header \f(CW\*(C`X\-Sendfile\-Type\*(C'\fR to a supported
type (\f(CW\*(C`X\-Accel\-Redirect\*(C'\fR for nginx, \f(CW\*(C`X\-Sendfile\*(C'\fR for Apache and
Lighttpd), could lead to the disclosure of private paths to malicious
clients setting that header.
.PP
Nginx needs the additional X\-Accel-Mapping header to be set in the
webserver configuration, so the middleware will replace the absolute
path of the \s-1IO\s0 object with the internal nginx path. This is also
useful to prevent a buggy app to server random files from the
filesystem, as it's an internal redirect.
.PP
An nginx configuration for FastCGI could look so:
.PP
.Vb 10
\& server {
\&     server_name example.com;
\&     root /my/app/root;
\&     location /private/repo/ {
\&         internal;
\&         alias /my/app/repo/;
\&     }
\&     location /private/staging/ {
\&         internal;
\&         alias /my/app/staging/;
\&     }
\&     location @proxy {
\&         include /etc/nginx/fastcgi_params;
\&         fastcgi_param SCRIPT_NAME \*(Aq\*(Aq;
\&         fastcgi_param PATH_INFO   $fastcgi_script_name;
\&         fastcgi_param HTTP_X_SENDFILE_TYPE X\-Accel\-Redirect;
\&         fastcgi_param HTTP_X_ACCEL_MAPPING /my/app=/private;
\&         fastcgi_pass  unix:/my/app/run/app.sock;
\&    }
\& }
.Ve
.PP
In the example above, passing filehandles with a local path matching
/my/app/staging or /my/app/repo will be served by nginx. Passing paths
with other locations will lead to an internal server error.
.PP
Setting the body to a filehandle without the \f(CW\*(C`path\*(C'\fR method bypasses
the middleware completely.
.PP
For Apache and Lighttpd, the mapping doesn't apply and setting the
X\-Sendfile-Type is enough.
.ie n .SS "$res\->has_body"
.el .SS "\f(CW$res\fP\->has_body"
.IX Subsection "$res->has_body"
Predicate which returns true when a body has been set.
.ie n .SS "$res\->code"
.el .SS "\f(CW$res\fP\->code"
.IX Subsection "$res->code"
Alias for \f(CW$res\fR\->status.
.ie n .SS "$res\->content_encoding"
.el .SS "\f(CW$res\fP\->content_encoding"
.IX Subsection "$res->content_encoding"
Shortcut for \f(CW$res\fR\->headers\->content_encoding.
.ie n .SS "$res\->content_length"
.el .SS "\f(CW$res\fP\->content_length"
.IX Subsection "$res->content_length"
Shortcut for \f(CW$res\fR\->headers\->content_length.
.ie n .SS "$res\->content_type"
.el .SS "\f(CW$res\fP\->content_type"
.IX Subsection "$res->content_type"
Shortcut for \f(CW$res\fR\->headers\->content_type.
.PP
This value is typically set by your view or plugin. For example,
Catalyst::Plugin::Static::Simple will guess the mime type based on the file
it found, while Catalyst::View::TT defaults to \f(CW\*(C`text/html\*(C'\fR.
.ie n .SS "$res\->content_type_charset"
.el .SS "\f(CW$res\fP\->content_type_charset"
.IX Subsection "$res->content_type_charset"
Shortcut for \f(CW$res\fR\->headers\->content_type_charset;
.ie n .SS "$res\->cookies"
.el .SS "\f(CW$res\fP\->cookies"
.IX Subsection "$res->cookies"
Returns a reference to a hash containing cookies to be set. The keys of the
hash are the cookies' names, and their corresponding values are hash
references used to construct a CGI::Simple::Cookie object.
.PP
.Vb 1
\&    $c\->response\->cookies\->{foo} = { value => \*(Aq123\*(Aq };
.Ve
.PP
The keys of the hash reference on the right correspond to the CGI::Simple::Cookie
parameters of the same name, except they are used without a leading dash.
Possible parameters are:
.IP "value" 4
.IX Item "value"
.PD 0
.IP "expires" 4
.IX Item "expires"
.IP "domain" 4
.IX Item "domain"
.IP "path" 4
.IX Item "path"
.IP "secure" 4
.IX Item "secure"
.IP "httponly" 4
.IX Item "httponly"
.PD
.ie n .SS "$res\->header"
.el .SS "\f(CW$res\fP\->header"
.IX Subsection "$res->header"
Shortcut for \f(CW$res\fR\->headers\->header.
.ie n .SS "$res\->headers"
.el .SS "\f(CW$res\fP\->headers"
.IX Subsection "$res->headers"
Returns an HTTP::Headers object, which can be used to set headers.
.PP
.Vb 1
\&    $c\->response\->headers\->header( \*(AqX\-Catalyst\*(Aq => $Catalyst::VERSION );
.Ve
.ie n .SS "$res\->output"
.el .SS "\f(CW$res\fP\->output"
.IX Subsection "$res->output"
Alias for \f(CW$res\fR\->body.
.ie n .SS "$res\->redirect( $url, $status )"
.el .SS "\f(CW$res\fP\->redirect( \f(CW$url\fP, \f(CW$status\fP )"
.IX Subsection "$res->redirect( $url, $status )"
Causes the response to redirect to the specified \s-1URL.\s0 The default status is
\&\f(CW302\fR.
.PP
.Vb 2
\&    $c\->response\->redirect( \*(Aqhttp://slashdot.org\*(Aq );
\&    $c\->response\->redirect( \*(Aqhttp://slashdot.org\*(Aq, 307 );
.Ve
.PP
This is a convenience method that sets the Location header to the
redirect destination, and then sets the response status.  You will
want to \f(CW\*(C` return \*(C'\fR or \f(CW\*(C`$c\->detach()\*(C'\fR to interrupt the normal
processing flow if you want the redirect to occur straight away.
.PP
\&\fBNote:\fR do not give a relative \s-1URL\s0 as \f(CW$url\fR, i.e: one that is not fully
qualified (= \f(CW\*(C`http://...\*(C'\fR, etc.) or that starts with a slash
(= \f(CW\*(C`/path/here\*(C'\fR). While it may work, it is not guaranteed to do the right
thing and is not a standard behaviour. You may opt to use \fBuri_for()\fR or
\&\fBuri_for_action()\fR instead.
.PP
\&\fBNote:\fR If \f(CW$url\fR is an object that does \->as_string (such as \s-1URI\s0, which is
what you get from \->uri_for) we automatically call that to stringify.  This
should ease the common case usage
.PP
.Vb 1
\&    return $c\->res\->redirect( $c\->uri_for(...));
.Ve
.ie n .SS "$res\->location"
.el .SS "\f(CW$res\fP\->location"
.IX Subsection "$res->location"
Sets or returns the \s-1HTTP\s0 'Location'.
.ie n .SS "$res\->status"
.el .SS "\f(CW$res\fP\->status"
.IX Subsection "$res->status"
Sets or returns the \s-1HTTP\s0 status.
.PP
.Vb 1
\&    $c\->response\->status(404);
.Ve
.PP
\&\f(CW$res\fR\->code is an alias for this, to match HTTP::Response\->code.
.ie n .SS "$res\->write( $data )"
.el .SS "\f(CW$res\fP\->write( \f(CW$data\fP )"
.IX Subsection "$res->write( $data )"
Writes \f(CW$data\fR to the output stream.  Calling this method will finalize your
headers and send the headers and status code response to the client (so changing
them afterwards is a waste... be sure to set your headers correctly first).
.PP
You may call this as often as you want throughout your response cycle.  You may
even set a 'body' afterward.  So for example you might write your \s-1HTTP\s0 headers
and the \s-1HEAD\s0 section of your document and then set the body from a template
driven from a database.  In some cases this can seem to the client as if you had
a faster overall response (but note that unless your server support chunked
body your content is likely to get queued anyway (Starman and most other
http 1.1 webservers support this).
.PP
If there is an encoding set, we encode each line of the response (the default
encoding is \s-1UTF\-8\s0).
.ie n .SS "$res\->unencoded_write( $data )"
.el .SS "\f(CW$res\fP\->unencoded_write( \f(CW$data\fP )"
.IX Subsection "$res->unencoded_write( $data )"
Works just like \->write but we don't apply any content encoding to \f(CW$data\fR.  Use
this if you are already encoding the \f(CW$data\fR or the data is arriving from an encoded
storage.
.ie n .SS "$res\->write_fh"
.el .SS "\f(CW$res\fP\->write_fh"
.IX Subsection "$res->write_fh"
Returns an instance of Catalyst::Response::Writer, which is a lightweight
decorator over the \s-1PSGI\s0 \f(CW$writer\fR object (see \s-1PSGI\s0.pod\eDelayed\-Response\-and\-Streaming\-Body).
.PP
In addition to proxying the \f(CW\*(C`write\*(C'\fR and \f(CW\*(C`close\*(C'\fR method from the underlying \s-1PSGI\s0
writer, this proxy object knows any application wide encoding, and provides a method
\&\f(CW\*(C`write_encoded\*(C'\fR that will properly encode your written lines based upon your
encoding settings.  By default in Catalyst responses are \s-1UTF\-8\s0 encoded and this
is the encoding used if you respond via \f(CW\*(C`write_encoded\*(C'\fR.  If you want to handle
encoding yourself, you can use the \f(CW\*(C`write\*(C'\fR method directly.
.PP
Encoding only applies to content types for which it matters.  Currently the following
content types are assumed to need encoding: text (including \s-1HTML\s0), xml and javascript.
.PP
We provide access to this object so that you can properly close over it for use in
asynchronous and nonblocking applications.  For example (assuming you are using a supporting
server, like Twiggy:
.PP
.Vb 1
\&    package AsyncExample::Controller::Root;
\&
\&    use Moose;
\&
\&    BEGIN { extends \*(AqCatalyst::Controller\*(Aq }
\&
\&    sub prepare_cb {
\&      my $write_fh = pop;
\&      return sub {
\&        my $message = shift;
\&        $write_fh\->write("Finishing: $message\en");
\&        $write_fh\->close;
\&      };
\&    }
\&
\&    sub anyevent :Local :Args(0) {
\&      my ($self, $c) = @_;
\&      my $cb = $self\->prepare_cb($c\->res\->write_fh);
\&
\&      my $watcher;
\&      $watcher = AnyEvent\->timer(
\&        after => 5,
\&        cb => sub {
\&          $cb\->(scalar localtime);
\&          undef $watcher; # cancel circular\-ref
\&        });
\&    }
.Ve
.PP
Like the 'write' method, calling this will finalize headers. Unlike 'write' when you
can this it is assumed you are taking control of the response so the body is never
finalized (there isn't one anyway) and you need to call the close method.
.ie n .SS "$res\->print( @data )"
.el .SS "\f(CW$res\fP\->print( \f(CW@data\fP )"
.IX Subsection "$res->print( @data )"
Prints \f(CW@data\fR to the output stream, separated by $,.  This lets you pass
the response object to functions that want to write to an IO::Handle.
.ie n .SS "$res\->\fBfinalize_headers()\fP"
.el .SS "\f(CW$res\fP\->\fBfinalize_headers()\fP"
.IX Subsection "$res->finalize_headers()"
Writes headers to response if not already written
.SS "from_psgi_response"
.IX Subsection "from_psgi_response"
Given a \s-1PSGI\s0 response (either three element \s-1ARRAY\s0 reference \s-1OR\s0 coderef expecting
a \f(CW$responder\fR) set the response from it.
.PP
Properly supports streaming and delayed response and / or async \s-1IO\s0 if running
under an expected event loop.
.PP
If passed an object, will expect that object to do a method \f(CW\*(C`as_psgi\*(C'\fR.
.PP
Example:
.PP
.Vb 1
\&    package MyApp::Web::Controller::Test;
\&
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&    use Plack::App::Directory;
\&
\&
\&    my $app = Plack::App::Directory\->new({ root => "/path/to/htdocs" })
\&      \->to_app;
\&
\&    sub myaction :Local Args {
\&      my ($self, $c) = @_;
\&      $c\->res\->from_psgi_response($app\->($c\->req\->env));
\&    }
\&
\&    sub streaming_body :Local {
\&      my ($self, $c) = @_;
\&      my $psgi_app = sub {
\&          my $respond = shift;
\&          my $writer = $respond\->([200,["Content\-Type" => "text/plain"]]);
\&          $writer\->write("body");
\&          $writer\->close;
\&      };
\&      $c\->res\->from_psgi_response($psgi_app);
\&    }
.Ve
.PP
Please note this does not attempt to map or nest your \s-1PSGI\s0 application under
the Controller and Action namespace or path. You may wish to review '\s-1PSGI\s0 Helpers'
under Catalyst::Utils for help in properly nesting applications.
.PP
\&\fB\s-1NOTE\s0\fR If your external \s-1PSGI\s0 application returns a response that has a character
set associated with the content type (such as \*(L"text/html; charset=UTF\-8\*(R") we set
\&\f(CW$c\fR\->clear_encoding to remove any additional content type encoding processing later
in the application (this is done to avoid double encoding issues).
.PP
\&\fB\s-1NOTE\s0\fR If your external \s-1PSGI\s0 application is streaming, we assume you completely
handle the entire jobs (including closing the stream).  This will also bypass
the output finalization methods on Catalyst (such as 'finalize_body' which gets
called but then skipped when it finds that output is already finished.)  Its possible
this might cause issue with some plugins that want to do 'things' during those
finalization methods.  Just understand what is happening.
.SS "encodable_content_type"
.IX Subsection "encodable_content_type"
This is a regular expression used to determine of the current content type
should be considered encodable.  Currently we apply default encoding (usually
\&\s-1UTF8\s0) to text type contents.  Here's the default regular expression:
.PP
This would match content types like:
.PP
.Vb 6
\&    text/plain
\&    text/html
\&    text/xml
\&    application/javascript
\&    application/xml
\&    application/vnd.user+xml
.Ve
.PP
\&\fB\s-1NOTE\s0\fR: We don't encode \s-1JSON\s0 content type responses by default since most
of the \s-1JSON\s0 serializers that are commonly used for this task will do so
automatically and we don't want to double encode.  If you are not using a
tool like \s-1JSON\s0 to produce \s-1JSON\s0 type content, (for example you are using
a template system, or creating the strings manually) you will need to either
encoding the body yourself:
.PP
.Vb 1
\&    $c\->response\->body( $c\->encoding\->encode( $body, $c\->_encode_check ) );
.Ve
.PP
Or you can alter the regular expression using this attribute.
.SS "encodable_response"
.IX Subsection "encodable_response"
Given a Catalyst::Response return true if its one that can be encoded.
.PP
.Vb 4
\&     make sure there is an encoding set on the response
\&     make sure the content type is encodable
\&     make sure no content type charset has been already set to something different from the global encoding
\&     make sure no content encoding is present.
.Ve
.PP
Note this does not inspect a body since we do allow automatic encoding on streaming
type responses.
.SS "\s-1DEMOLISH\s0"
.IX Subsection "DEMOLISH"
Ensures that the response is flushed and closed at the end of the
request.
.SS "meta"
.IX Subsection "meta"
Provided by Moose
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.
