.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::UTF8 3pm"
.TH Catalyst::UTF8 3pm "2020-07-26" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Catalyst::UTF8 \- All About \s-1UTF8\s0 and Catalyst Encoding
.SH "Description"
.IX Header "Description"
Starting in 5.90080 Catalyst will enable \s-1UTF8\s0 encoding by default for
text like body responses.  In addition we've made a ton of fixes around encoding
and utf8 scattered throughout the codebase.  This document attempts to give
an overview of the assumptions and practices that  Catalyst uses when
dealing with \s-1UTF8\s0 and encoding issues.  You should also review the
Changes file, Catalyst::Delta and Catalyst::Upgrading for more.
.PP
We attempt to describe all relevant processes, try to give some advice
and explain where we may have been exceptional to respect our commitment
to backwards compatibility.
.SH "UTF8 in Controller Actions"
.IX Header "UTF8 in Controller Actions"
Using \s-1UTF8\s0 characters in your Controller classes and actions.
.SS "Summary"
.IX Subsection "Summary"
In this section we will review changes to how \s-1UTF8\s0 characters can be used in
controller actions, how it looks in the debugging screens (and your logs)
as well as how you construct \s-1URL\s0 objects to actions with \s-1UTF8\s0 paths
(or using \s-1UTF8\s0 args or captures).
.SS "Unicode in Controllers and URLs"
.IX Subsection "Unicode in Controllers and URLs"
.Vb 1
\&    package MyApp::Controller::Root;
\&
\&    use utf8;
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&
\&    sub heart_with_arg :Path(\*(Aq♥\*(Aq) Args(1)  {
\&      my ($self, $c, $arg) = @_;
\&    }
\&
\&    sub base :Chained(\*(Aq/\*(Aq) CaptureArgs(0) {
\&      my ($self, $c) = @_;
\&    }
\&
\&      sub capture :Chained(\*(Aqbase\*(Aq) PathPart(\*(Aq♥\*(Aq) CaptureArgs(1) {
\&        my ($self, $c, $capture) = @_;
\&      }
\&
\&        sub arg :Chained(\*(Aqcapture\*(Aq) PathPart(\*(Aq♥\*(Aq) Args(1) {
\&          my ($self, $c, $arg) = @_;
\&        }
.Ve
.SS "Discussion"
.IX Subsection "Discussion"
In the example controller above we have constructed two matchable \s-1URL\s0 routes:
.PP
.Vb 2
\&    http://localhost/root/♥/{arg}
\&    http://localhost/base/♥/{capture}/♥/{arg}
.Ve
.PP
The first one is a classic Path type action and the second uses Chaining, and
spans three actions in total.  As you can see, you can use unicode characters
in your Path and PathPart attributes (remember to use the \f(CW\*(C`utf8\*(C'\fR pragma to allow
these multibyte characters in your source).  The two constructed matchable routes
would match the following incoming URLs:
.PP
.Vb 2
\&    (heart_with_arg) \-> http://localhost/root/%E2%99%A5/{arg}
\&    (base/capture/arg) \-> http://localhost/base/%E2%99%A5/{capture}/%E2%99%A5/{arg}
.Ve
.PP
That path path \f(CW\*(C`%E2%99%A5\*(C'\fR is url encoded unicode (assuming you are hitting this with
a reasonably modern browser).  Its basically what goes over \s-1HTTP\s0 when your type a
browser location that has the unicode 'heart' in it.  However we will use the unicode
symbol in your debugging messages:
.PP
.Vb 6
\&    [debug] Loaded Path actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path                                | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /root/♥/*                          | /root/heart_with_arg                  |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&
\&    [debug] Loaded Chained actions:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Path Spec                           | Private                              |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | /base/♥/*/♥/*                       | /root/base (0)                       |
\&    |                                     | \-> /root/capture (1)                 |
\&    |                                     | => /root/arg                         |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
And if the requested \s-1URL\s0 uses unicode characters in your captures or args (such as
\&\f(CW\*(C`http://localhost:/base/♥/♥/♥/♥\*(C'\fR) you should see the arguments and captures as their
unicode characters as well:
.PP
.Vb 9
\&    [debug] Arguments are "♥"
\&    [debug] "GET" request for "base/♥/♥/♥/♥" from "127.0.0.1"
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-.
\&    | Action                                                     | Time      |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+
\&    | /root/base                                                 | 0.000080s |
\&    | /root/capture                                              | 0.000075s |
\&    | /root/arg                                                  | 0.000755s |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
Again, remember that we are display the unicode character and using it to match actions
containing such multibyte characters \s-1BUT\s0 over \s-1HTTP\s0 you are getting these as \s-1URL\s0 encoded
bytes.  For example if you looked at the \s-1PSGI\s0 \f(CW$env\fR value for \f(CW\*(C`REQUEST_URI\*(C'\fR you
would see (for the above request)
.PP
.Vb 1
\&    REQUEST_URI => "/base/%E2%99%A5/%E2%99%A5/%E2%99%A5/%E2%99%A5"
.Ve
.PP
So on the incoming request we decode so that we can match and display unicode characters
(after decoding the \s-1URL\s0 encoding).  This makes it straightforward to use these types of
multibyte characters in your actions and see them incoming in captures and arguments.  Please
keep this in might if you are doing for example regular expression matching, length determination
or other string comparisons, you will need to try these incoming variables as though \s-1UTF8\s0
strings.  For example in the following action:
.PP
.Vb 3
\&        sub arg :Chained(\*(Aqcapture\*(Aq) PathPart(\*(Aq♥\*(Aq) Args(1) {
\&          my ($self, $c, $arg) = @_;
\&        }
.Ve
.PP
when \f(CW$arg\fR is \*(L"♥\*(R" you should expect \f(CW\*(C`length($arg)\*(C'\fR to be \f(CW1\fR since it is indeed one character
although it will take more than one byte to store.
.ie n .SS "\s-1UTF8\s0 in constructing URLs via $c\->uri_for"
.el .SS "\s-1UTF8\s0 in constructing URLs via \f(CW$c\fP\->uri_for"
.IX Subsection "UTF8 in constructing URLs via $c->uri_for"
For the reverse (constructing meaningful URLs to actions that contain multibyte characters
in their paths or path parts, or when you want to include such characters in your captures
or arguments) Catalyst will do the right thing (again just remember to use the \f(CW\*(C`utf8\*(C'\fR
pragma).
.PP
.Vb 2
\&    use utf8;
\&    my $url = $c\->uri_for( $c\->controller(\*(AqRoot\*(Aq)\->action_for(\*(Aqarg\*(Aq), [\*(Aq♥\*(Aq,\*(Aq♥\*(Aq]);
.Ve
.PP
When you stringify this object (for use in a template, for example) it will automatically
do the right thing regarding utf8 encoding and url encoding.
.PP
.Vb 1
\&    http://localhost/base/%E2%99%A5/%E2%99%A5/%E2%99%A5/%E2%99%A5
.Ve
.PP
Since again what you want is a properly url encoded version of this.  In this case your string
length will reflect \s-1URL\s0 encoded bytes, not the character length.  Ultimately what you want
to send over the wire via \s-1HTTP\s0 needs to be bytes.
.SH "UTF8 in GET Query and Form POST"
.IX Header "UTF8 in GET Query and Form POST"
What Catalyst does with \s-1UTF8\s0 in your \s-1GET\s0 and classic \s-1HTML\s0 Form \s-1POST\s0
.SS "\s-1UTF8\s0 in \s-1URL\s0 query and keywords"
.IX Subsection "UTF8 in URL query and keywords"
The same rules that we find in \s-1URL\s0 paths also cover \s-1URL\s0 query parts.  That is
if one types a \s-1URL\s0 like this into the browser
.PP
.Vb 1
\&    http://localhost/example?♥=♥♥
.Ve
.PP
When this goes 'over the wire' to your application server its going to be as
percent encoded bytes:
.PP
.Vb 1
\&    http://localhost/example?%E2%99%A5=%E2%99%A5%E2%99%A5
.Ve
.PP
When Catalyst encounters this we decode the percent encoding and the utf8
so that we can properly display this information (such as in the debugging
logs or in a response.)
.PP
.Vb 6
\&    [debug] Query Parameters are:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Parameter                           | Value                                |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | ♥                                   | ♥♥                                   |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
All the values and keys that are part of \f(CW$c\fR\->req\->query_parameters will be
utf8 decoded.  So you should not need to do anything special to take those
values/keys and send them to the body response (since as we will see later
Catalyst will do all the necessary encoding for you).
.PP
Again, remember that values of your parameters are now decode into Unicode strings.  so
for example you'd expect the result of length to reflect the character length not
the byte length.
.PP
Just like with arguments and captures, you can use utf8 literals (or utf8
strings) in \f(CW$c\fR\->uri_for:
.PP
.Vb 2
\&    use utf8;
\&    my $url = $c\->uri_for( $c\->controller(\*(AqRoot\*(Aq)\->action_for(\*(Aqexample\*(Aq), {\*(Aq♥\*(Aq => \*(Aq♥♥\*(Aq});
.Ve
.PP
When you stringify this object (for use in a template, for example) it will automatically
do the right thing regarding utf8 encoding and url encoding.
.PP
.Vb 1
\&    http://localhost/example?%E2%99%A5=%E2%99%A5%E2%99%A5
.Ve
.PP
Since again what you want is a properly url encoded version of this.  Ultimately what you want
to send over the wire via \s-1HTTP\s0 needs to be bytes (not unicode characters).
.PP
Remember if you use any utf8 literals in your source code, you should use the
\&\f(CW\*(C`use utf8\*(C'\fR pragma.
.PP
\&\fB\s-1NOTE:\s0\fR Assuming \s-1UTF\-8\s0 in your query parameters and keywords may be an issue if you have
legacy code where you created \s-1URL\s0 in templates manually and used an encoding other than \s-1UTF\-8.\s0
In these cases you may find versions of Catalyst after 5.90080+ will incorrectly decode.  For
backwards compatibility we offer three configurations settings, here described in order of
precedence:
.PP
\&\f(CW\*(C`do_not_decode_query\*(C'\fR
.PP
If true, then do not try to character decode any wide characters in your
request \s-1URL\s0 query or keywords.  You will need to handle this manually in your action code
(although if you choose this setting, chances are you already do this).
.PP
\&\f(CW\*(C`default_query_encoding\*(C'\fR
.PP
This setting allows one to specify a fixed value for how to decode your query, instead of using
the default, \s-1UTF\-8.\s0
.PP
\&\f(CW\*(C`decode_query_using_global_encoding\*(C'\fR
.PP
If this is true we decode using whatever you set \f(CW\*(C`encoding\*(C'\fR to.
.SS "\s-1UTF8\s0 in Form \s-1POST\s0"
.IX Subsection "UTF8 in Form POST"
In general most modern browsers will follow the specification, which says that POSTed
form fields should be encoded in the same way that the document was served with.  That means
that if you are using modern Catalyst and serving \s-1UTF8\s0 encoded responses, a browser is
supposed to notice that and encode the form POSTs accordingly.
.PP
As a result since Catalyst now serves \s-1UTF8\s0 encoded responses by default, this means that
you can mostly rely on incoming form POSTs to be so encoded.  Catalyst will make this
assumption and decode accordingly (unless you explicitly turn off encoding...)  If you are
running Catalyst in developer debug, then you will see the correct unicode characters in
the debug output.  For example if you generate a \s-1POST\s0 request:
.PP
.Vb 2
\&    use Catalyst::Test \*(AqMyApp\*(Aq;
\&    use utf8;
\&
\&    my $res = request POST "/example/posted", [\*(Aq♥\*(Aq=>\*(Aq♥\*(Aq, \*(Aq♥♥\*(Aq=>\*(Aq♥\*(Aq];
.Ve
.PP
Running in CATALYST_DEBUG=1 mode you should see output like this:
.PP
.Vb 7
\&    [debug] Body Parameters are:
\&    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&    | Parameter                           | Value                                |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | ♥                                   | ♥                                    |
\&    | ♥♥                                  | ♥                                    |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
And if you had a controller like this:
.PP
.Vb 1
\&    package MyApp::Controller::Example;
\&
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&
\&    sub posted :POST Local {
\&        my ($self, $c) = @_;
\&        $c\->res\->content_type(\*(Aqtext/plain\*(Aq);
\&        $c\->res\->body("hearts => ${\e$c\->req\->post_parameters\->{♥}}");
\&    }
.Ve
.PP
The following test case would be true:
.PP
.Vb 2
\&    use Encode 2.21 \*(Aqdecode_utf8\*(Aq;
\&    is decode_utf8($req\->content), \*(Aqhearts => ♥\*(Aq;
.Ve
.PP
In this case we decode so that we can print and compare strings with multibyte characters.
.PP
\&\fB\s-1NOTE\s0\fR  In some cases some browsers may not follow the specification and set the form \s-1POST\s0
encoding based on the server response.  Catalyst itself doesn't attempt any workarounds, but one
common approach is to use a hidden form field with a \s-1UTF8\s0 value (You might be familiar with
this from how Ruby on Rails has \s-1HTML\s0 form helpers that do that automatically).  In that case
some browsers will send \s-1UTF8\s0 encoded if it notices the hidden input field contains such a
character.  Also, you can add an \s-1HTML\s0 attribute to your form tag which many modern browsers
will respect to set the encoding (accept\-charset=\*(L"utf\-8\*(R").  And lastly there are some javascript
based tricks and workarounds for even more odd cases (just search the web for this will return
a number of approaches.  Hopefully as more compliant browsers become popular these edge cases
will fade.
.PP
\&\fB\s-1NOTE\s0\fR  It is possible for a form \s-1POST\s0 multipart response (normally a file upload) to contain
inline content with mixed content character sets and encoding.  For example one might create
a \s-1POST\s0 like this:
.PP
.Vb 2
\&    use utf8;
\&    use HTTP::Request::Common;
\&
\&    my $utf8 = \*(Aqtest ♥\*(Aq;
\&    my $shiftjs = \*(Aqtest テスト\*(Aq;
\&    my $req = POST \*(Aq/root/echo_arg\*(Aq,
\&        Content_Type => \*(Aqform\-data\*(Aq,
\&          Content =>  [
\&            arg0 => \*(Aqhelloworld\*(Aq,
\&            Encode::encode(\*(AqUTF\-8\*(Aq,\*(Aq♥\*(Aq) => Encode::encode(\*(AqUTF\-8\*(Aq,\*(Aq♥♥\*(Aq),
\&            arg1 => [
\&              undef, \*(Aq\*(Aq,
\&              \*(AqContent\-Type\*(Aq =>\*(Aqtext/plain; charset=UTF\-8\*(Aq,
\&              \*(AqContent\*(Aq => Encode::encode(\*(AqUTF\-8\*(Aq, $utf8)],
\&            arg2 => [
\&              undef, \*(Aq\*(Aq,
\&              \*(AqContent\-Type\*(Aq =>\*(Aqtext/plain; charset=SHIFT_JIS\*(Aq,
\&              \*(AqContent\*(Aq => Encode::encode(\*(AqSHIFT_JIS\*(Aq, $shiftjs)],
\&            arg2 => [
\&              undef, \*(Aq\*(Aq,
\&              \*(AqContent\-Type\*(Aq =>\*(Aqtext/plain; charset=SHIFT_JIS\*(Aq,
\&              \*(AqContent\*(Aq => Encode::encode(\*(AqSHIFT_JIS\*(Aq, $shiftjs)],
\&          ];
.Ve
.PP
In this case we've created a \s-1POST\s0 request but each part specifies its own content
character set (and setting a content encoding would also be possible).  Generally one
would not run into this situation in a web browser context but for completeness sake
Catalyst will notice if a multipart \s-1POST\s0 contains parts with complex or extended
header information.  In these cases we will try to inspect the meta data and do the
right thing (in the above case we'd use \s-1SHIFT_JIS\s0 to decode, not \s-1UTF\-8\s0).  However if
after inspecting the headers we cannot figure out how to decode the data, in those cases it
will not attempt to apply decoding to the form values.  Instead the part will be represented as
an instance of an object Catalyst::Request::PartData which will contain all the header
information needed for you to perform custom parser of the data.
.PP
Ideally we'd fix Catalyst to be smarter about decoding so please submit your cases of
this so we can add intelligence to the parser and find a way to extract a valid value out
of it.
.SH "UTF8 Encoding in Body Response"
.IX Header "UTF8 Encoding in Body Response"
When does Catalyst encode your response body and what rules does it use to
determine when that is needed.
.SS "Summary"
.IX Subsection "Summary"
.Vb 3
\&    use utf8;
\&    use warnings;
\&    use strict;
\&
\&    package MyApp::Controller::Root;
\&
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&    use File::Spec;
\&
\&    sub scalar_body :Local {
\&        my ($self, $c) = @_;
\&        $c\->response\->content_type(\*(Aqtext/html\*(Aq);
\&        $c\->response\->body("<p>This is scalar_body action ♥</p>");
\&    }
\&
\&    sub stream_write :Local {
\&        my ($self, $c) = @_;
\&        $c\->response\->content_type(\*(Aqtext/html\*(Aq);
\&        $c\->response\->write("<p>This is stream_write action ♥</p>");
\&    }
\&
\&    sub stream_write_fh :Local {
\&        my ($self, $c) = @_;
\&        $c\->response\->content_type(\*(Aqtext/html\*(Aq);
\&
\&        my $writer = $c\->res\->write_fh;
\&        $writer\->write_encoded(\*(Aq<p>This is stream_write_fh action ♥</p>\*(Aq);
\&        $writer\->close;
\&    }
\&
\&    sub stream_body_fh :Local {
\&        my ($self, $c) = @_;
\&        my $path = File::Spec\->catfile(\*(Aqt\*(Aq, \*(Aqutf8.txt\*(Aq);
\&        open(my $fh, \*(Aq<\*(Aq, $path) || die "trouble: $!";
\&        $c\->response\->content_type(\*(Aqtext/html\*(Aq);
\&        $c\->response\->body($fh);
\&    }
.Ve
.SS "Discussion"
.IX Subsection "Discussion"
Beginning with Catalyst version 5.90080 You no longer need to set the encoding
configuration (although doing so won't hurt anything).
.PP
Currently we only encode if the content type is one of the types which generally expects a
\&\s-1UTF8\s0 encoding.  This is determined by the following regular expression:
.PP
.Vb 2
\&    our $DEFAULT_ENCODE_CONTENT_TYPE_MATCH = qr{text|xml$|javascript$};
\&    $c\->response\->content_type =~ /$DEFAULT_ENCODE_CONTENT_TYPE_MATCH/
.Ve
.PP
This is a global variable in Catalyst::Response which is stored in the \f(CW\*(C`encodable_content_type\*(C'\fR
attribute of \f(CW$c\fR\->response.  You may currently alter this directly on the response or globally.  In
the future we may offer a configuration setting for this.
.PP
This would match content-types like the following (examples)
.PP
.Vb 6
\&    text/plain
\&    text/html
\&    text/xml
\&    application/javascript
\&    application/xml
\&    application/vnd.user+xml
.Ve
.PP
You should set your content type prior to header finalization if you want Catalyst to
encode.
.PP
\&\fB\s-1NOTE\s0\fR We do not attempt to encode \f(CW\*(C`application/json\*(C'\fR since the two most commonly used
approaches (Catalyst::View::JSON and Catalyst::Action::REST) have already configured
their \s-1JSON\s0 encoders to produce properly encoding \s-1UTF8\s0 responses.  If you are rolling your
own \s-1JSON\s0 encoding, you may need to set the encoder to do the right thing (or override
the global regular expression to include the \s-1JSON\s0 media type).
.SS "Encoding with Scalar Body"
.IX Subsection "Encoding with Scalar Body"
Catalyst supports several methods of supplying your response with body content.  The first
and currently most common is to set the Catalyst::Response \->body with a scalar string (
as in the example):
.PP
.Vb 1
\&    use utf8;
\&
\&    sub scalar_body :Local {
\&        my ($self, $c) = @_;
\&        $c\->response\->content_type(\*(Aqtext/html\*(Aq);
\&        $c\->response\->body("<p>This is scalar_body action ♥</p>");
\&    }
.Ve
.PP
In general you should need to do nothing else since Catalyst will automatically encode
this string during body finalization.  The only matter to watch out for is to make sure
the string has not already been encoded, as this will result in double encoding errors.
.PP
\&\fB\s-1NOTE\s0\fR pay attention to the content-type setting in the example.  Catalyst inspects that
content type carefully to determine if the body needs encoding).
.PP
\&\fB\s-1NOTE\s0\fR If you set the character set of the response Catalyst will skip encoding \s-1IF\s0 the
character set is set to something that doesn't match \f(CW$c\fR\->encoding\->mime_name. We will assume
if you are setting an alternative character set, that means you want to handle the encoding
yourself.  However it might be easier to set \f(CW$c\fR\->encoding for a given response cycle since
you can override this for a given response.  For example here's how to override the default
encoding and set the correct character set in the response:
.PP
.Vb 6
\&    sub override_encoding :Local {
\&        my ($self, $c) = @_;
\&        $c\->res\->content_type(\*(Aqtext/plain\*(Aq);
\&        $c\->encoding(Encode::find_encoding(\*(AqShift_JIS\*(Aq));
\&        $c\->response\->body("テスト");
\&    }
.Ve
.PP
This will use the alternative encoding for a single response.
.PP
\&\fB\s-1NOTE\s0\fR If you manually set the content-type character set to whatever \f(CW$c\fR\->encoding\->mime_name
is set to, we \s-1STILL\s0 encode, rather than assume your manual setting is a flag to override.  This
is done to support backward compatible assumptions (in particular Catalyst::View::TT has set
a utf\-8 character set in its default content-type for ages, even though it does not itself do any
encoding on the body response).  If you are going to handle encoding manually you may set
\&\f(CW$c\fR\->clear_encoding for a single request response cycle, or as in the above example set an alternative
encoding.
.SS "Encoding with streaming type responses"
.IX Subsection "Encoding with streaming type responses"
Catalyst offers two approaches to streaming your body response.  Again, you must remember
to set your content type prior to streaming, since invoking a streaming response will automatically
finalize and send your \s-1HTTP\s0 headers (and your content type \s-1MUST\s0 be one that matches the regular
expression given above.)
.PP
Also, if you are going to override \f(CW$c\fR\->encoding (or invoke \f(CW$c\fR\->clear_encoding), you should do
that before anything else!
.PP
The first streaming method is to use the \f(CW\*(C`write\*(C'\fR method on the response object.  This method
allows 'inlined' streaming and is generally used with blocking style servers.
.PP
.Vb 5
\&    sub stream_write :Local {
\&        my ($self, $c) = @_;
\&        $c\->response\->content_type(\*(Aqtext/html\*(Aq);
\&        $c\->response\->write("<p>This is stream_write action ♥</p>");
\&    }
.Ve
.PP
You may call the \f(CW\*(C`write\*(C'\fR method as often as you need to finish streaming all your content.
Catalyst will encode each line in turn as long as the content-type meets the 'encodable types'
requirement and \f(CW$c\fR\->encoding is set (which it is, as long as you did not change it).
.PP
\&\fB\s-1NOTE\s0\fR If you try to change the encoding after you start the stream, this will invoke an error
response.  However since you've already started streaming this will not show up as an \s-1HTTP\s0 error
status code, but rather error information in your body response and an error in your logs.
.PP
\&\fB\s-1NOTE\s0\fR If you use \->body \s-1AFTER\s0 using \->write (for example you may do this to write your \s-1HTML
HEAD\s0 information as fast as possible) we expect the contents to body to be encoded as it
normally would be if you never called \->write.  In general unless you are doing weird custom
stuff with encoding this is likely to just already do the correct thing.
.PP
The second way to stream a response is to get the response writer object and invoke methods
on that directly:
.PP
.Vb 3
\&    sub stream_write_fh :Local {
\&        my ($self, $c) = @_;
\&        $c\->response\->content_type(\*(Aqtext/html\*(Aq);
\&
\&        my $writer = $c\->res\->write_fh;
\&        $writer\->write_encoded(\*(Aq<p>This is stream_write_fh action ♥</p>\*(Aq);
\&        $writer\->close;
\&    }
.Ve
.PP
This can be used just like the \f(CW\*(C`write\*(C'\fR method, but typically you request this object when
you want to do a nonblocking style response since the writer object can be closed over or
sent to a model that will invoke it in a non blocking manner.  For more on using the writer
object for non blocking responses you should review the \f(CW\*(C`Catalyst\*(C'\fR documentation and also
you can look at several articles from last years advent, in particular:
.PP
<http://www.catalystframework.org/calendar/2013/10>, <http://www.catalystframework.org/calendar/2013/11>,
<http://www.catalystframework.org/calendar/2013/12>, <http://www.catalystframework.org/calendar/2013/13>,
<http://www.catalystframework.org/calendar/2013/14>.
.PP
The main difference this year is that previously calling \->write_fh would return the actual
Plack writer object that was supplied by your Plack application handler, whereas now we wrap
that object in a lightweight decorator object that proxies the \f(CW\*(C`write\*(C'\fR and \f(CW\*(C`close\*(C'\fR methods
and supplies an additional \f(CW\*(C`write_encoded\*(C'\fR method.  \f(CW\*(C`write_encoded\*(C'\fR does the exact same thing
as \f(CW\*(C`write\*(C'\fR except that it will first encode the string when necessary.  In general if you are
streaming encodable content such as \s-1HTML\s0 this is the method to use.  If you are streaming
binary content, you should just use the \f(CW\*(C`write\*(C'\fR method (although if the content type is set
correctly we would skip encoding anyway, but you may as well avoid the extra noop overhead).
.PP
The last style of content response that Catalyst supports is setting the body to a filehandle
like object.  In this case the object is passed down to the Plack application handler directly
and currently we do nothing to set encoding.
.PP
.Vb 7
\&    sub stream_body_fh :Local {
\&        my ($self, $c) = @_;
\&        my $path = File::Spec\->catfile(\*(Aqt\*(Aq, \*(Aqutf8.txt\*(Aq);
\&        open(my $fh, \*(Aq<\*(Aq, $path) || die "trouble: $!";
\&        $c\->response\->content_type(\*(Aqtext/html\*(Aq);
\&        $c\->response\->body($fh);
\&    }
.Ve
.PP
In this example we create a filehandle to a text file that contains \s-1UTF8\s0 encoded characters. We
pass this down without modification, which I think is correct since we don't want to double
encode.  However this may change in a future development release so please be sure to double
check the current docs and changelog.  Its possible a future release will require you to to set
a encoding on the \s-1IO\s0 layer level so that we can be sure to properly encode at body finalization.
So this is still an edge case we are writing test examples for.  But for now if you are returning
a filehandle like response, you are expected to make sure you are following the \s-1PSGI\s0 specification
and return raw bytes.
.SS "Override the Encoding on Context"
.IX Subsection "Override the Encoding on Context"
As already noted you may change the current encoding (or remove it) by setting an alternative
encoding on the context;
.PP
.Vb 1
\&    $c\->encoding(Encode::find_encoding(\*(AqShift_JIS\*(Aq));
.Ve
.PP
Please note that you can continue to change encoding \s-1UNTIL\s0 the headers have been finalized.  The
last setting always wins.  Trying to change encoding after header finalization is an error.
.SS "Setting the Content Encoding \s-1HTTP\s0 Header"
.IX Subsection "Setting the Content Encoding HTTP Header"
In some cases you may set a content encoding on your response.  For example if you are encoding
your response with gzip.  In this case you are again on your own.  If we notice that the
content encoding header is set when we hit finalization, we skip automatic encoding:
.PP
.Vb 3
\&    use Encode;
\&    use Compress::Zlib;
\&    use utf8;
\&
\&    sub gzipped :Local {
\&        my ($self, $c) = @_;
\&
\&        $c\->res\->content_type(\*(Aqtext/plain\*(Aq);
\&        $c\->res\->content_type_charset(\*(AqUTF\-8\*(Aq);
\&        $c\->res\->content_encoding(\*(Aqgzip\*(Aq);
\&
\&        $c\->response\->body(
\&          Compress::Zlib::memGzip(
\&            Encode::encode_utf8("manual_1 ♥")));
\&    }
.Ve
.PP
If you are using Catalyst::Plugin::Compress you need to upgrade to the most recent version
in order to be compatible with changes introduced in Catalyst 5.90080.  Other plugins may
require updates (please open bugs if you find them).
.PP
\&\fB\s-1NOTE\s0\fR Content encoding may be set to 'identify' and we will still perform automatic encoding
if the content type is encodable and an encoding is present for the context.
.SS "Using Common Views"
.IX Subsection "Using Common Views"
The following common views have been updated so that their tests pass with default \s-1UTF8\s0
encoding for Catalyst:
.PP
Catalyst::View::TT, Catalyst::View::Mason, Catalyst::View::HTML::Mason,
Catalyst::View::Xslate
.PP
See Catalyst::Upgrading for additional information on Catalyst extensions that require
upgrades.
.PP
In generally for the common views you should not need to do anything special.  If your actual
template files contain \s-1UTF8\s0 literals you should set configuration on your View to enable that.
For example in \s-1TT,\s0 if your template has actual \s-1UTF8\s0 character in it you should do the following:
.PP
.Vb 1
\&    MyApp::View::TT\->config(ENCODING => \*(Aqutf\-8\*(Aq);
.Ve
.PP
However Catalyst::View::Xslate wants to do the \s-1UTF8\s0 encoding for you (We assume that the
authors of that view did this as a workaround to the fact that until now encoding was not core
to Catalyst.  So if you use that view, you either need to tell it to not encode, or you need
to turn off encoding for Catalyst.
.PP
.Vb 1
\&    MyApp::View::Xslate\->config(encode_body => 0);
.Ve
.PP
or
.PP
.Vb 1
\&    MyApp\->config(encoding=>undef);
.Ve
.PP
Preference is to disable it in the View.
.PP
Other views may be similar.  You should review View documentation and test during upgrading.
We tried to make sure most common views worked properly and noted all workaround but if we
missed something please alert the development team (instead of introducing a local hack into
your application that will mean nobody will ever upgrade it...).
.SS "Setting the response from an external \s-1PSGI\s0 application."
.IX Subsection "Setting the response from an external PSGI application."
Catalyst::Response allows one to set the response from an external \s-1PSGI\s0 application.
If you do this, and that external application sets a character set on the content-type, we
\&\f(CW\*(C`clear_encoding\*(C'\fR for the rest of the response.  This is done to prevent double encoding.
.PP
\&\fB\s-1NOTE\s0\fR Even if the character set of the content type is the same as the encoding set in
\&\f(CW$c\fR\->encoding, we still skip encoding.  This is a regrettable difference from the general rule
outlined above, where if the current character set is the same as the current encoding, we
encode anyway.  Nevertheless I think this is the correct behavior since the earlier rule exists
only to support backward compatibility with Catalyst::View::TT.
.PP
In general if you want Catalyst to handle encoding, you should avoid setting the content
type character set since Catalyst will do so automatically based on the requested response
encoding.  Its best to request alternative encodings by setting \f(CW$c\fR\->encoding and if you  really
want manual control of encoding you should always \f(CW$c\fR\->clear_encoding so that programmers that
come after you are very clear as to your intentions.
.SS "Disabling default \s-1UTF8\s0 encoding"
.IX Subsection "Disabling default UTF8 encoding"
You may encounter issues with your legacy code running under default \s-1UTF8\s0 body encoding.  If
so you can disable this with the following configurations setting:
.PP
.Vb 1
\&    MyApp\->config(encoding=>undef);
.Ve
.PP
Where \f(CW\*(C`MyApp\*(C'\fR is your Catalyst subclass.
.PP
If you do not wish to disable all the Catalyst encoding features, you may disable specific
features via two additional configuration options:  'skip_body_param_unicode_decoding'
and 'skip_complex_post_part_handling'.  The first will skip any attempt to decode \s-1POST\s0
parameters in the creating of body parameters and the second will skip creation of instances
of Catalyst::Request::PartData in the case that the multipart form upload contains parts
with a mix of content character sets.
.PP
If you believe you have discovered a bug in \s-1UTF8\s0 body encoding, I strongly encourage you to
report it (and not try to hack a workaround in your local code).  We also recommend that you
regard such a workaround as a temporary solution.  It is ideal if Catalyst extension
authors can start to count on Catalyst doing the right thing for encoding.
.SH "Conclusion"
.IX Header "Conclusion"
This document has attempted to be a complete review of how \s-1UTF8\s0 and encoding works in the
current version of Catalyst and also to document known issues, gotchas and backward
compatible hacks.  Please report issues to the development team.
.SH "Author"
.IX Header "Author"
John Napiorkowski jjnapiork@cpan.org <mailto:jjnapiork@cpan.org>
