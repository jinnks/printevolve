.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::Upgrading 3pm"
.TH Catalyst::Upgrading 3pm "2020-07-26" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Upgrading \- Instructions for upgrading to the latest Catalyst
.SH "Upgrading to Catalyst 5.90121"
.IX Header "Upgrading to Catalyst 5.90121"
A new \f(CW\*(C`log_stats\*(C'\fR method has been added. This will only affect
subclasses that have a method with this name added.
.SH "Upgrading to Catalyst 5.90100"
.IX Header "Upgrading to Catalyst 5.90100"
We changed the way the middleware stash works so that it no longer localizes
the \s-1PSGI\s0 env hashref.  This was done to fix bugs where people set \s-1PSGI ENV\s0 hash
keys and found them to disappear in certain cases.  It also means that now if
a sub applications sets stash variables, that stash will now bubble up to the
parent application.  This may be a breaking change for you since previous
versions of this code did not allow that.  A workaround is to explicitly delete
stash keys in your sub application before returning control to the parent
application.
.SH "Upgrading to Catalyst 5.90097"
.IX Header "Upgrading to Catalyst 5.90097"
In older versions of Catalyst one could construct a \s-1URI\s0 with a fragment (such as
https://localhost/foo/bar#fragment) by using a '#' in the path or final argument, for
example:
.PP
.Vb 1
\&    $c\->uri_for($action, \*(Aqfoo#fragment\*(Aq);
.Ve
.PP
This behavior was never documented and would break if using the Unicode plugin, or when
adding a query to the arguments:
.PP
.Vb 1
\&    $c\->uri_for($action, \*(Aqfoo#fragment\*(Aq, +{ a=>1, b=>2});
.Ve
.PP
would define a fragment like \*(L"#fragment?a=1&b=2\*(R".
.PP
When we introduced \s-1UTF\-8\s0 encoding by default in Catalyst 5.9008x this side effect behavior
was broken since we started encoding the '#' when it was part of the \s-1URI\s0 path.
.PP
In version 5.90095 and 5.90096 we attempted to fix this, but all we managed to do was break
people with URIs that included '#' as part of the path data, when it was not expected to
be a fragment delimiter.
.PP
In general Catalyst prefers an explicit specification rather than relying on side effects
or domain specific mini languages.  As a result we are now defining how to set a fragment
for a \s-1URI\s0 via \->uri_for:
.PP
.Vb 1
\&    $c\->uri_for($action_or_path, \e@captures_or_args, @args, \e$query, \e$fragment);
.Ve
.PP
If you are relying on the previous side effect behavior your URLs will now encode the '#'
delimiter, which is going to be a breaking change for you.  You need to alter your code
to match the new specification or modify uri_for for your local case.  Patches to solve
this are very welcomed, as long as they don't break existing test cases.
.PP
\&\fB\s-1NOTE\s0\fR If you are using the string form of the first argument:
.PP
.Vb 1
\&    $c\->uri_for(\*(Aq/foo/bar#baz\*(Aq)
.Ve
.PP
construction, we do not attempt to encode this and it will make a \s-1URL\s0 with a
fragment of 'baz'.
.SH "Upgrading to Catalyst 5.90095"
.IX Header "Upgrading to Catalyst 5.90095"
The method \f(CW\*(C`last_error\*(C'\fR in \*(L"Catalyst\*(R" was actually returning the first error.  This has
been fixed but there is a small chance it could be a breaking issue for you.  If this gives
you trouble changing to \f(CW\*(C`shift_errors\*(C'\fR is the easiest workaround (although that does
modify the error stack so if you are relying on that not being changed you should try something
like @{$c\->errors}[\-1] instead.  Since this method is relatively new and the cases when the
error stack actually has more than one error in it, we feel the exposure is very low, but bug
reports are very welcomed.
.SH "Upgrading to Catalyst 5.90090"
.IX Header "Upgrading to Catalyst 5.90090"
Catalyst::Utils has a new method 'inject_component' which works the same as the method of
the same name in CatalystX::InjectComponent.  You should start converting any
use of the non core method in your code as future changes to Catalyst will be
synchronized to the core method first.  We reserve the right to cease support
of the non core version should we reach a point in time where it cannot be
properly supported as an external module.  Luckily this should be a trivial
search and replace.  Change all occurrences of:
.PP
.Vb 1
\&    CatalystX::InjectComponent\->inject(...)
.Ve
.PP
Into
.PP
.Vb 1
\&    Catalyst::Utils::inject_component(...)
.Ve
.PP
and we expect everything to work the same (we'd consider it not working the same
to be a bug, and please report it.)
.PP
We also cored features from CatalystX::RoleApplicator to compose a role into the
request, response and stats classes.  The main difference is that with CatalystX::RoleApplicator
you did:
.PP
.Vb 1
\&    package MyApp;
\&
\&    use Catalyst;
\&    use CatalystX::RoleApplicator;
\&
\&    _\|_PACKAGE_\|_\->apply_request_class_roles(
\&      qw/My::Request::Role Other::Request::Role/);
.Ve
.PP
Whereas now we have three class attributes, 'request_class_traits', 'response_class_traits'
and 'stats_class_traits', so you use like this (note this value is an ArrayRef)
.PP
.Vb 1
\&    package MyApp;
\&
\&    use Catalyst;
\&
\&    _\|_PACKAGE_\|_\->request_class_traits([qw/
\&      My::Request::Role
\&      Other::Request::Role/]);
.Ve
.PP
(And the same for response_class_traits and stats_class_traits.  We left off the
traits for Engine, since that class does a lot less nowadays, and dispatcher.  If you
used those and can share a use case, we'd be likely to support them.
.PP
Lastly, we have some of the feature from CatalystX::ComponentsFromConfig in
core.  This should mostly work the same way in core, except for now the
core version does not create an automatic base wrapper class for your configured
components (it requires these to be catalyst components and injects them directly.
So if you make heavy use of custom base classes in CatalystX::ComponentsFromConfig
you might need a bit of work to use the core version (although there is no reason
to stop using CatalystX::ComponentsFromConfig since it should continue to work
fine and we'd consider issues with it to be bugs).  Here's one way to map from
CatalystX::ComponentsFromConfig to core:
.PP
In CatalystX::ComponentsFromConfig:
.PP
.Vb 4
\&    MyApp\->config(
\&      \*(AqModel::MyClass\*(Aq => {
\&          class => \*(AqMyClass\*(Aq,
\&          args => { %args },
\&
\&      });
.Ve
.PP
and now in core:
.PP
.Vb 8
\&    MyApp\->config(
\&      inject_components => {
\&        \*(AqModel::MyClass\*(Aq => { from_component => \*(AqMy::Class\*(Aq },
\&      },
\&      \*(AqModel::MyClass\*(Aq => {
\&        %args
\&      },
\&    );
.Ve
.PP
Although the core behavior requires more code, it better separates concerns
as well as plays more into core Catalyst expectations of how configuration should
look.
.PP
Also we added a new develop console mode only warning when you call a component
with arguments that don't expect or do anything meaningful with those args.  Its
possible if you are logging debug mode in production (please don't...) this
could add verbosity to those logs if you also happen to be calling for components
and passing pointless arguments.  We added this warning to help people not make this
error and to better understand the component resolution flow.
.SH "Upgrading to Catalyst 5.90085"
.IX Header "Upgrading to Catalyst 5.90085"
In this version of Catalyst we made a small change to Chained Dispatching so
that when two or more actions all have the same path specification \s-1AND\s0 they
all have \fBArgs\fR\|(0), we break the tie by choosing the last action defined, and
not the first one defined.  This was done to normalize Chaining to following
the 'longest Path wins, and when several actions match the same Path specification
we choose the last defined.' rule. Previously \fBArgs\fR\|(0) was hard coded to be a special
case such that the first action defined would match (which is not the case when
Args is not zero.)
.PP
Its possible that this could be a breaking change for you, if you had used
action roles (custom or otherwise) to add additional matching rules to differentiate
between several \fBArgs\fR\|(0) actions that share the same root action chain.  For
example if you have code now like this:
.PP
.Vb 1
\&    sub check_default :Chained(/) CaptureArgs(0) { ... }
\&
\&      sub default_get :Chained(\*(Aqcheck_default\*(Aq) PathPart(\*(Aq\*(Aq) Args(0) GET {
\&          pop\->res\->body(\*(Aqget3\*(Aq);
\&      }
\&
\&      sub default_post :Chained(\*(Aqcheck_default\*(Aq) PathPart(\*(Aq\*(Aq) Args(0) POST {
\&          pop\->res\->body(\*(Aqpost3\*(Aq);
\&      }
\&
\&      sub chain_default :Chained(\*(Aqcheck_default\*(Aq) PathPart(\*(Aq\*(Aq) Args(0) {
\&          pop\->res\->body(\*(Aqchain_default\*(Aq);
\&      }
.Ve
.PP
The way that chaining will work previous is that when two or more equal actions can
match, the 'top' one wins.  So if the request is \*(L"\s-1GET ..\s0./check_default\*(R" \s-1BOTH\s0
actions 'default_get' \s-1AND\s0 'chain_default' would match.  To break the tie in
the case when Args is 0, we'd previous take the 'top' (or first defined) action.
Unfortunately this treatment of \fBArgs\fR\|(0) is special case.  In all other cases
we choose the 'last defined' action to break a tie.  So this version of
Catalyst changed the dispatcher to make \fBArgs\fR\|(0) no longer a special case for
breaking ties.  This means that the above code must now become:
.PP
.Vb 1
\&    sub check_default :Chained(/) CaptureArgs(0) { ... }
\&
\&      sub chain_default :Chained(\*(Aqcheck_default\*(Aq) PathPart(\*(Aq\*(Aq) Args(0) {
\&          pop\->res\->body(\*(Aqchain_default\*(Aq);
\&      }
\&
\&      sub default_get :Chained(\*(Aqcheck_default\*(Aq) PathPart(\*(Aq\*(Aq) Args(0) GET {
\&          pop\->res\->body(\*(Aqget3\*(Aq);
\&      }
\&
\&      sub default_post :Chained(\*(Aqcheck_default\*(Aq) PathPart(\*(Aq\*(Aq) Args(0) POST {
\&          pop\->res\->body(\*(Aqpost3\*(Aq);
\&      }
.Ve
.PP
If we want it to work as expected (for example we we \s-1GET\s0 to match 'default_get' and
\&\s-1POST\s0 to match 'default_post' and any other http Method to match 'chain_default').
.PP
In other words \fBArg\fR\|(0) and chained actions must now follow the normal rule where
in a tie the last defined action wins and you should place all your less defined
or 'catch all' actions first.
.PP
If this causes you trouble and you can't fix your code to conform, you may set the
application configuration setting \*(L"use_chained_args_0_special_case\*(R" to true and
that will revert you code to the previous behavior.
.SS "More backwards compatibility options with \s-1UTF\-8\s0 changes"
.IX Subsection "More backwards compatibility options with UTF-8 changes"
In order to give better backwards compatibility with the 5.90080+ \s-1UTF\-8\s0 changes
we've added several configuration options around control of how we try to decode
your \s-1URL\s0 keywords / query parameters.
.PP
\&\f(CW\*(C`do_not_decode_query\*(C'\fR
.PP
If true, then do not try to character decode any wide characters in your
request \s-1URL\s0 query or keywords.  Most readings of the relevant specifications
suggest these should be UTF\-* encoded, which is the default that Catalyst
will use, however if you are creating a lot of URLs manually or have external
evil clients, this might cause you trouble.  If you find the changes introduced
in Catalyst version 5.90080+ break some of your query code, you may disable
the \s-1UTF\-8\s0 decoding globally using this configuration.
.PP
This setting takes precedence over \f(CW\*(C`default_query_encoding\*(C'\fR and
\&\f(CW\*(C`decode_query_using_global_encoding\*(C'\fR
.PP
\&\f(CW\*(C`default_query_encoding\*(C'\fR
.PP
By default we decode query and keywords in your request \s-1URL\s0 using \s-1UTF\-8,\s0 which
is our reading of the relevant specifications.  This setting allows one to
specify a fixed value for how to decode your query.  You might need this if
you are doing a lot of custom encoding of your URLs and not using \s-1UTF\-8.\s0
.PP
This setting take precedence over \f(CW\*(C`decode_query_using_global_encoding\*(C'\fR.
.PP
\&\f(CW\*(C`decode_query_using_global_encoding\*(C'\fR
.PP
Setting this to true will default your query decoding to whatever your
general global encoding is (the default is \s-1UTF\-8\s0).
.SH "Upgrading to Catalyst 5.90080"
.IX Header "Upgrading to Catalyst 5.90080"
\&\s-1UTF8\s0 encoding is now default.  For temporary backwards compatibility, if this
change is causing you trouble, you can disable it by setting the application
configuration option to undef:
.PP
.Vb 1
\&    MyApp\->config(encoding => undef);
.Ve
.PP
But please consider this a temporary measure since it is the intention that
\&\s-1UTF8\s0 is enabled going forwards and the expectation is that other ecosystem
projects will assume this as well.  At some point you application will not
correctly function without this setting.
.PP
As of 5.90084 we've added two additional configuration flags for more selective
control over some encoding changes: 'skip_body_param_unicode_decoding' and
\&'skip_complex_post_part_handling'.  You may use these to more selectively
disable new features while you are seeking a long term fix.  Please review
\&\s-1CONFIGURATION\s0 in Catalyst.
.PP
For further information, please see Catalyst::UTF8
.PP
A number of projects in the wider ecosystem required minor updates to be able
to work correctly.  Here's the known list:
.PP
Catalyst::View::TT, Catalyst::View::Mason, Catalyst::View::HTML::Mason,
Catalyst::View::Xslate, Test::WWW::Mechanize::Catalyst
.PP
You will need to update to modern versions in most cases, although quite a few
of these only needed minor test case and documentation changes so you will need
to review the changelog of each one that is relevant to you to determine your
true upgrade needs.
.SH "Upgrading to Catalyst 5.90060"
.IX Header "Upgrading to Catalyst 5.90060"
Starting in the v5.90059_001 development release, the regexp dispatch type is
no longer automatically included as a dependency.  If you are still using this
dispatch type, you need to add Catalyst::DispatchType::Regex into your build
system.
.PP
The standalone distribution of Regexp will be supported for the time being, but
should we find that supporting it prevents us from moving Catalyst forward
in necessary ways, we reserve the right to drop that support.  It is highly
recommended that you use this last stage of deprecation to change your code.
.SH "Upgrading to Catalyst 5.90040"
.IX Header "Upgrading to Catalyst 5.90040"
.SS "Catalyst::Plugin::Unicode::Encoding is now core"
.IX Subsection "Catalyst::Plugin::Unicode::Encoding is now core"
The previously stand alone Unicode support module Catalyst::Plugin::Unicode::Encoding
has been brought into core as a default plugin.  Going forward, all you need is
to add a configuration setting for the encoding type.  For example:
.PP
.Vb 1
\&    package Myapp::Web;
\&
\&    use Catalyst;
\&
\&    _\|_PACKAGE_\|_\->config( encoding => \*(AqUTF\-8\*(Aq );
.Ve
.PP
Please note that this is different from the old stand alone plugin which applied
\&\f(CW\*(C`UTF\-8\*(C'\fR encoding by default (that is, if you did not set an explicit
\&\f(CW\*(C`encoding\*(C'\fR configuration value, it assumed you wanted \s-1UTF\-8\s0).  In order to
preserve backwards compatibility you will need to explicitly turn it on via the
configuration setting.  \s-1THIS MIGHT CHANGE IN THE FUTURE,\s0 so please consider
starting to test your application with proper \s-1UTF\-8\s0 support and remove all those
crappy hacks you munged into the code because you didn't know the Plugin
existed :)
.PP
For people that are using the Plugin, you will note a startup warning suggesting
that you can remove it from the plugin list.  When you do so, please remember to
add the configuration setting, since you can no longer rely on the default being
\&\s-1UTF\-8.\s0  We'll add it for you if you continue to use the stand alone plugin and
we detect this, but this backwards compatibility shim will likely be removed in
a few releases (trying to clean up the codebase after all).
.PP
If you have trouble with any of this, please bring it to the attention of the
Catalyst maintainer group.
.SS "basic async and event loop support"
.IX Subsection "basic async and event loop support"
This version of Catalyst offers some support for using AnyEvent and
IO::Async event loops in your application.  These changes should work
fine for most applications however if you are already trying to perform
some streaming, minor changes in this area of the code might affect your
functionality.  Please see Catalyst::Response\ewrite_fh for more and for a
basic example.
.PP
We consider this feature experimental.  We will try not to break it, but we
reserve the right to make necessary changes to fix major issues that people
run into when the use this functionality in the wild.
.SH "Upgrading to Catalyst 5.90030"
.IX Header "Upgrading to Catalyst 5.90030"
.SS "Regex dispatch type is deprecated."
.IX Subsection "Regex dispatch type is deprecated."
The Regex dispatchtype (Catalyst::DispatchType::Regex) has been deprecated.
.PP
You are encouraged to move your application to Chained dispatch (Catalyst::DispatchType::Chained).
.PP
If you cannot do so, please add a dependency to Catalyst::DispatchType::Regex to your application's
Makefile.PL
.SH "Upgrading to Catalyst 5.9"
.IX Header "Upgrading to Catalyst 5.9"
The major change is that Plack, a toolkit for using the \s-1PSGI\s0
specification, now replaces most of the subclasses of Catalyst::Engine. If
you are using one of the standard subclasses of Catalyst::Engine this
should be a straightforward upgrade for you. It was a design goal for
this release to preserve as much backwards compatibility as possible.
However, since Plack is different from Catalyst::Engine, it is
possible that differences exist for edge cases. Therefore, we recommend
that care be taken with this upgrade and that testing should be greater
than would be the case with a minor point update. Please inform the
Catalyst developers of any problems so that we can fix them and
incorporate tests.
.PP
It is highly recommended that you become familiar with the Plack ecosystem
and documentation. Being able to take advantage of Plack development and
middleware is a major bonus to this upgrade. Documentation about how to
take advantage of Plack::Middleware by writing your own \f(CW\*(C`.psgi\*(C'\fR file
is contained in Catalyst::PSGI.
.PP
If you have created a custom subclass of <Catalyst:Engine>, you will
need to convert it to be a subclass of Plack::Handler.
.PP
If you are using the Plack engine, Catalyst::Engine::PSGI, this new
release supersedes that code.
.PP
If you are using a subclass of Catalyst::Engine that is aimed at
nonstandard or internal/testing uses, such as
Catalyst::Engine::Embeddable, you should still be able to continue
using that engine.
.PP
Advice for specific subclasses of Catalyst::Engine follows:
.SS "Upgrading the FastCGI Engine"
.IX Subsection "Upgrading the FastCGI Engine"
No upgrade is needed if your myapp_fastcgi.pl script is already upgraded
to use Catalyst::Script::FastCGI.
.SS "Upgrading the mod_perl / Apache Engines"
.IX Subsection "Upgrading the mod_perl / Apache Engines"
The engines that are built upon the various iterations of mod_perl,
Catalyst::Engine::Apache::MP13 (for mod_perl 1, and Apache 1.x) and
Catalyst::Engine::Apache2::MP20 (for mod_perl 2, and Apache 2.x),
should be seamless upgrades and will work using Plack::Handler::Apache1
or Plack::Handler::Apache2 as required.
.PP
Catalyst::Engine::Apache2::MP19, however, is no longer supported, as
Plack does not support mod_perl version 1.99. This is unlikely to be a
problem for anyone, as 1.99 was a brief beta-test release for mod_perl
2, and all users of mod_perl 1.99 are encouraged to upgrade to a
supported release of Apache 2 and mod_perl 2.
.SS "Upgrading the \s-1HTTP\s0 Engine"
.IX Subsection "Upgrading the HTTP Engine"
The default development server that comes with the Catalyst distribution
should continue to work as expected with no changes as long as your \f(CW\*(C`myapp_server\*(C'\fR
script is upgraded to use Catalyst::Script::HTTP.
.SS "Upgrading the \s-1CGI\s0 Engine"
.IX Subsection "Upgrading the CGI Engine"
If you were using Catalyst::Engine::CGI there is no upgrade needed if your
myapp_cgi.pl script is already upgraded to use Catalyst::Script::CGI.
.SS "Upgrading Catalyst::Engine::HTTP::Prefork"
.IX Subsection "Upgrading Catalyst::Engine::HTTP::Prefork"
If you were using Catalyst::Engine::HTTP::Prefork then Starman
is automatically loaded. You should (at least) change your \f(CW\*(C`Makefile.PL\*(C'\fR
to depend on Starman.
.PP
You can regenerate your \f(CW\*(C`myapp_server.pl\*(C'\fR script with \f(CW\*(C`catalyst.pl\*(C'\fR
and implement a \f(CW\*(C`MyApp::Script::Server\*(C'\fR class that looks like this:
.PP
.Vb 3
\&    package MyApp::Script::Server;
\&    use Moose;
\&    use namespace::autoclean;
\&
\&    extends \*(AqCatalystX::Script::Server::Starman\*(Aq;
\&
\&    1;
.Ve
.PP
This takes advantage of the new script system, and will add a number of
options to the standard server script as extra options are added by
Starman.
.PP
More information about these options can be seen at
\&\*(L"\s-1SYNOPSIS\*(R"\s0 in CatalystX::Script::Server::Starman.
.PP
An alternate route to implement this functionality is to write a simple .psgi
file for your application, and then use the plackup utility to start the
server.
.SS "Upgrading the \s-1PSGI\s0 Engine"
.IX Subsection "Upgrading the PSGI Engine"
If you were using Catalyst::Engine::PSGI, this new release supersedes
this engine in supporting Plack. By default the Engine is now always
Plack. As a result, you can remove the dependency on
Catalyst::Engine::PSGI in your \f(CW\*(C`Makefile.PL\*(C'\fR.
.PP
Applications that were using Catalyst::Engine::PSGI
previously should entirely continue to work in this release with no changes.
.PP
However, if you have an \f(CW\*(C`app.psgi\*(C'\fR script, then you no longer need to
specify the \s-1PSGI\s0 engine. Instead, the Catalyst application class now
has a new method \f(CW\*(C`psgi_app\*(C'\fR which returns a \s-1PSGI\s0 compatible coderef
which you can wrap in the middleware of your choice.
.PP
Catalyst will use the .psgi for your application if it is located in the \f(CW\*(C`home\*(C'\fR
directory of the application.
.PP
For example, if you were using Catalyst::Engine::PSGI in the past, you will
have written (or generated) a \f(CW\*(C`script/myapp.psgi\*(C'\fR file similar to this one:
.PP
.Vb 2
\&    use Plack::Builder;
\&    use MyCatalytApp;
\&
\&    MyCatalystApp\->setup_engine(\*(AqPSGI\*(Aq);
\&
\&    builder {
\&        enable ... # enable your desired middleware
\&        sub { MyCatalystApp\->run(@_) };
\&    };
.Ve
.PP
Instead, you now say:
.PP
.Vb 2
\&    use Plack::Builder;
\&    use MyCatalystApp;
\&
\&    builder {
\&        enable ... #enable your desired middleware
\&        MyCatalystApp\->psgi_app;
\&    };
.Ve
.PP
In the simplest case:
.PP
.Vb 2
\&    MyCatalystApp\->setup_engine(\*(AqPSGI\*(Aq);
\&    my $app = sub { MyCatalystApp\->run(@_) }
.Ve
.PP
becomes
.PP
.Vb 1
\&    my $app = MyCatalystApp\->psgi_app(@_);
.Ve
.PP
\&\fB\s-1NOT\s0\fR:
.PP
.Vb 2
\&    my $app = sub { MyCatalystApp\->psgi_app(@_) };
\&    # If you make ^^ this mistake, your app won\*(Aqt work, and will confuse the hell out of you!
.Ve
.PP
You can now move \f(CW\*(C`script/myapp.psgi\*(C'\fR to \f(CW\*(C`myapp.psgi\*(C'\fR, and the built-in
Catalyst scripts and your test suite will start using your .psgi file.
.PP
\&\fB\s-1NOTE:\s0\fR If you rename your .psgi file without these modifications, then
any tests run via Catalyst::Test will not be compatible with the new
release, and will result in the development server starting, rather than
the expected test running.
.PP
\&\fB\s-1NOTE:\s0\fR If you are directly accessing \f(CW\*(C`$c\->req\->env\*(C'\fR to get the \s-1PSGI\s0
environment then this accessor is moved to \f(CW\*(C`$c\->engine\->env\*(C'\fR,
you will need to update your code.
.SS "Engines which are known to be broken"
.IX Subsection "Engines which are known to be broken"
The following engines \fB\s-1DO NOT\s0\fR work as of Catalyst version 5.9. The
core team will be happy to work with the developers and/or users of
these engines to help them port to the new Plack/Engine system, but for
now, applications which are currently using these engines \fB\s-1WILL NOT\s0\fR
run without modification to the engine code.
.IP "Catalyst::Engine::Wx" 4
.IX Item "Catalyst::Engine::Wx"
.PD 0
.IP "Catalyst::Engine::Zeus" 4
.IX Item "Catalyst::Engine::Zeus"
.IP "Catalyst::Engine::JobQueue::POE" 4
.IX Item "Catalyst::Engine::JobQueue::POE"
.IP "Catalyst::Engine::XMPP2" 4
.IX Item "Catalyst::Engine::XMPP2"
.IP "Catalyst::Engine::SCGI" 4
.IX Item "Catalyst::Engine::SCGI"
.PD
.SS "Engines with unknown status"
.IX Subsection "Engines with unknown status"
The following engines are untested or have unknown compatibility.
Reports are highly encouraged:
.IP "Catalyst::Engine::Mojo" 4
.IX Item "Catalyst::Engine::Mojo"
.PD 0
.IP "Catalyst::Engine::Server (marked as Deprecated)" 4
.IX Item "Catalyst::Engine::Server (marked as Deprecated)"
.IP "Catalyst::Engine::HTTP::POE (marked as Deprecated)" 4
.IX Item "Catalyst::Engine::HTTP::POE (marked as Deprecated)"
.PD
.SS "Plack functionality"
.IX Subsection "Plack functionality"
See Catalyst::PSGI.
.SS "Tests in 5.9"
.IX Subsection "Tests in 5.9"
Tests should generally work the same in Catalyst 5.9, but there are
some differences.
.PP
Previously, if using Catalyst::Test and doing local requests (against
a local server), if the application threw an exception then this
exception propagated into the test.
.PP
This behavior has been removed, and now a 500 response will be returned
to the test. This change standardizes behavior, so that local test
requests behave similarly to remote requests.
.SH "Upgrading to Catalyst 5.80"
.IX Header "Upgrading to Catalyst 5.80"
Most applications and plugins should run unaltered on Catalyst 5.80.
.PP
However, a lot of refactoring work has taken place, and several changes have
been made which could cause incompatibilities. If your application or plugin
is using deprecated code, or relying on side effects, then you could have
issues upgrading to this release.
.PP
Most issues found with existing components have been easy to
solve. This document provides a complete description of behavior changes
which may cause compatibility issues, and of new Catalyst warnings which
might be unclear.
.PP
If you think you have found an upgrade-related issue which is not covered in
this document, please email the Catalyst list to discuss the problem.
.SH "Moose features"
.IX Header "Moose features"
.SS "Application class roles"
.IX Subsection "Application class roles"
You can only apply method modifiers after the application's \f(CW\*(C`\->setup\*(C'\fR
method has been called. This means that modifiers will not work with methods
run during the call to \f(CW\*(C`\->setup\*(C'\fR.
.PP
See Catalyst::Manual::ExtendingCatalyst for more information about using
Moose in your applications.
.SS "Controller actions in Moose roles"
.IX Subsection "Controller actions in Moose roles"
You can use MooseX::MethodAttributes::Role if you want to declare actions
inside Moose roles.
.SS "Using Moose in Components"
.IX Subsection "Using Moose in Components"
The correct way to use Moose in a component in a both forward and backwards
compatible way is:
.PP
.Vb 3
\&    package TestApp::Controller::Root;
\&    use Moose;
\&    BEGIN { extends \*(AqCatalyst::Component\*(Aq }; # Or ::Controller, or whatever
.Ve
.PP
See \*(L"Components which inherit from Moose::Object before Catalyst::Component\*(R".
.SH "Known backwards compatibility breakages"
.IX Header "Known backwards compatibility breakages"
.SS "Applications in a single file"
.IX Subsection "Applications in a single file"
Applications must be in their own file, and loaded at compile time. This
issue generally only affects the tests of \s-1CPAN\s0 distributions. Your
application will fail if you try to define an application inline in a
block, and use plugins which supply a \f(CW\*(C` new \*(C'\fR method, then use that
application latter in tests within the same file.
.PP
This is due to the fact that Catalyst is inlining a new method on your
application class allowing it to be compatible with Moose. The method
used to do this changed in 5.80004 to avoid the possibility of reporting
an 'Unknown Error' if your application failed to compile.
.SS "Issues with Class::C3"
.IX Subsection "Issues with Class::C3"
Catalyst 5.80 uses the Algorithm::C3 method dispatch order. This is
built into Perl 5.10, and comes via Class::C3 for Perl 5.8. This
replaces \s-1NEXT\s0 with Class::C3::Adopt::NEXT, forcing all components
to resolve methods using C3, rather than the unpredictable dispatch
order of \s-1NEXT\s0.
.PP
This issue manifests itself by your application failing to start due to an
error message about having a non-linear \f(CW@ISA\fR.
.PP
The Catalyst plugin most often causing this is
Catalyst::Plugin::Session::Store::FastMmap \- if you are using this
plugin and see issues, then please upgrade your plugins, as it has been
fixed. Note that Makefile.PL in the distribution will warn about known
incompatible components.
.PP
This issue can, however, be found in your own application \- the only solution is
to go through each base class of the class the error was reported against, until
you identify the ones in conflict, and resolve them.
.PP
To be able to generate a linear \f(CW@ISA\fR, the list of superclasses for each
class must be resolvable using the C3 algorithm. Unfortunately, when
superclasses are being used as mixins (to add functionality used in your class),
and with multiple inheritance, it is easy to get this wrong.
.PP
Most common is the case of:
.PP
.Vb 2
\&    package Component1; # Note, this is the common case
\&    use base qw/Class::Accessor::Fast Class::Data::Inheritable/;
\&
\&    package Component2; # Accidentally saying it this way causes a failure
\&    use base qw/Class::Data::Inheritable Class::Accessor::Fast/;
\&
\&    package GoesBang;
\&    use base qw/Component1 Component2/;
.Ve
.PP
Any situation like this will cause your application to fail to start.
.PP
For additional documentation about this issue, and how to resolve it, see
Class::C3::Adopt::NEXT.
.SS "Components which inherit from Moose::Object before Catalyst::Component"
.IX Subsection "Components which inherit from Moose::Object before Catalyst::Component"
Moose components which say:
.PP
.Vb 3
\&    package TestApp::Controller::Example;
\&    use Moose;
\&    extends qw/Moose::Object Catalyst::Component/;
.Ve
.PP
to use the constructor provided by Moose, while working (if you do some hacks
with the \f(CW\*(C` BUILDARGS \*(C'\fR method), will not work with Catalyst 5.80 as
\&\f(CW\*(C`Catalyst::Component\*(C'\fR inherits from \f(CW\*(C`Moose::Object\*(C'\fR, and so \f(CW @ISA \fR fails
to linearize.
.PP
The correct way to use Moose in a component in a both forward and backwards
compatible way is:
.PP
.Vb 3
\&    package TestApp::Controller::Root;
\&    use Moose;
\&    BEGIN { extends \*(AqCatalyst::Component\*(Aq }; # Or ::Controller, or whatever
.Ve
.PP
Note that the \f(CW\*(C` extends \*(C'\fR declaration needs to occur in a begin block for
attributes to operate correctly.
.PP
This way you do not inherit directly from \f(CW\*(C`Moose::Object\*(C'\fR
yourself. Having components which do not inherit their constructor from
\&\f(CW\*(C`Catalyst::Component\*(C'\fR is \fBunsupported\fR, and has never been recommended,
therefore you're on your own if you're using this technique. You'll need
to detect the version of Catalyst your application is running, and deal
with it appropriately.
.PP
You also don't get the Moose::Object constructor, and therefore attribute
initialization will not work as normally expected. If you want to use Moose
attributes, then they need to be made lazy to correctly initialize.
.PP
Note that this only applies if your component needs to maintain component
backwards compatibility for Catalyst versions before 5.71001 \- in 5.71001
attributes work as expected, and the \s-1BUILD\s0 method is called normally
(although \s-1BUILDARGS\s0 is not).
.PP
If you depend on Catalyst 5.8, then \fBall\fR Moose features work as expected.
.PP
You will also see this issue if you do the following:
.PP
.Vb 3
\&    package TestApp::Controller::Example;
\&    use Moose;
\&    use base \*(AqCatalyst::Controller\*(Aq;
.Ve
.PP
as \f(CW\*(C` use base \*(C'\fR appends to \f(CW@ISA\fR.
.PP
\fIuse Moose in MyApp\fR
.IX Subsection "use Moose in MyApp"
.PP
Similar to the above, this will also fail:
.PP
.Vb 6
\&    package MyApp;
\&    use Moose;
\&    use Catalyst qw/
\&      ConfigLoader
\&    /;
\&    _\|_PACKAGE_\|_\->setup;
.Ve
.PP
If you need to use Moose in your application class (e.g. for method modifiers
etc.) then the correct technique is:
.PP
.Vb 3
\&    package MyApp;
\&    use Moose;
\&    use Catalyst;
\&
\&    extends \*(AqCatalyst\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->config( name => \*(AqMyApp\*(Aq );
\&    _\|_PACKAGE_\|_\->setup(qw/
\&        ConfigLoader
\&    /);
.Ve
.SS "Anonymous closures installed directly into the symbol table"
.IX Subsection "Anonymous closures installed directly into the symbol table"
If you have any code which installs anonymous subroutine references directly
into the symbol table, you may encounter breakages. The simplest solution is
to use Sub::Name to name the subroutine. Example:
.PP
.Vb 3
\&    # Original code, likely to break:
\&    my $full_method_name = join(\*(Aq::\*(Aq, $package_name, $method_name);
\&    *$full_method_name = sub { ... };
\&
\&    # Fixed Code
\&    use Sub::Name \*(Aqsubname\*(Aq;
\&    my $full_method_name = join(\*(Aq::\*(Aq,$package_name, $method_name);
\&    *$full_method_name = subname $full_method_name, sub { ... };
.Ve
.PP
Additionally, you can take advantage of Catalyst's use of Class::MOP and
install the closure using the appropriate metaclass. Example:
.PP
.Vb 3
\&    use Class::MOP;
\&    my $metaclass = Moose::Meta::Class\->initialize($package_name);
\&    $metaclass\->add_method($method_name => sub { ... });
.Ve
.SS "Hooking into application setup"
.IX Subsection "Hooking into application setup"
To execute code during application start-up, the following snippet in MyApp.pm
used to work:
.PP
.Vb 5
\&    sub setup {
\&        my ($class, @args) = @_;
\&        $class\->NEXT::setup(@args);
\&        ... # things to do after the actual setup
\&    }
.Ve
.PP
With Catalyst 5.80 this won't work anymore, because Catalyst no longer
uses \s-1NEXT\s0.pm for method resolution. The functionality was only ever
originally operational as \s-1NEXT\s0 remembers what methods have already
been called, and will not call them again.
.PP
Using this now causes infinite recursion between MyApp::setup and
Catalyst::setup, due to other backwards compatibility issues related to how
plugin setup works. Moose method modifiers like \f(CW\*(C`before|after|around setup
=> sub { ... };\*(C'\fR also will not operate correctly on the setup method.
.PP
The right way to do it is this:
.PP
.Vb 3
\&    after setup_finalize => sub {
\&        ... # things to do after the actual setup
\&    };
.Ve
.PP
The setup_finalize hook was introduced as a way to avoid this issue.
.SS "Components with a new method which returns false"
.IX Subsection "Components with a new method which returns false"
Previously, if you had a component which inherited from Catalyst::COMPONENT,
but overrode the new method to return false, then your class's configuration
would be blessed into a hash on your behalf, and this would be returned from
the \s-1COMPONENT\s0 method.
.PP
This behavior makes no sense, and so has been removed. Implementing your own
\&\f(CW\*(C` new \*(C'\fR method in components is \fBhighly\fR discouraged. Instead, you should
inherit the new method from Catalyst::Component, and use Moose's \s-1BUILD\s0
functionality and/or Moose attributes to perform any construction work
necessary for your class.
.SS "_\|_PACKAGE_\|_\->mk_accessor('meta');"
.IX Subsection "__PACKAGE__->mk_accessor('meta');"
Won't work due to a limitation of Moose. This is currently being fixed
inside Moose.
.SS "Class::Data::Inheritable side effects"
.IX Subsection "Class::Data::Inheritable side effects"
Previously, writing to a class data accessor would copy the accessor method
down into your package.
.PP
This behavior has been removed. While the class data is still stored
per-class, it is stored on the metaclass of the class defining the accessor.
.PP
Therefore anything relying on the side effect of the accessor being copied down
will be broken.
.PP
The following test demonstrates the problem:
.PP
.Vb 5
\&    {
\&        package BaseClass;
\&        use base qw/Class::Data::Inheritable/;
\&        _\|_PACKAGE_\|_\->mk_classdata(\*(Aqfoo\*(Aq);
\&    }
\&
\&    {
\&        package Child;
\&        use base qw/BaseClass/;
\&    }
\&
\&    BaseClass\->foo(\*(Aqbase class\*(Aq);
\&    Child\->foo(\*(Aqsub class\*(Aq);
\&
\&    use Test::More;
\&    isnt(BaseClass\->can(\*(Aqfoo\*(Aq), Child\->can(\*(Aqfoo\*(Aq));
.Ve
.SS "Extending Catalyst::Request or other classes in an ad hoc manner using mk_accessors"
.IX Subsection "Extending Catalyst::Request or other classes in an ad hoc manner using mk_accessors"
Previously, it was possible to add additional accessors to Catalyst::Request
(or other classes) by calling the mk_accessors class method.
.PP
This is no longer supported \- users should make a subclass of the class whose
behavior they would like to change, rather than globally polluting the
Catalyst objects.
.SS "Confused multiple inheritance with Catalyst::Component::COMPONENT"
.IX Subsection "Confused multiple inheritance with Catalyst::Component::COMPONENT"
Previously, Catalyst's \s-1COMPONENT\s0 method would delegate to the method on
the right hand side, which could then delegate back again with
\&\s-1NEXT.\s0 This is poor practice, and in addition, makes no sense with C3
method dispatch order, and is therefore no longer supported.
.PP
If a \s-1COMPONENT\s0 method is detected in the inheritance hierarchy to the right
hand side of Catalyst::Component::COMPONENT, then the following warning
message will be emitted:
.PP
.Vb 2
\&    There is a COMPONENT method resolving after Catalyst::Component
\&    in ${next_package}.
.Ve
.PP
The correct fix is to re-arrange your class's inheritance hierarchy so that the
\&\s-1COMPONENT\s0 method you would like to inherit is the first (left-hand most)
\&\s-1COMPONENT\s0 method in your \f(CW@ISA\fR.
.SS "Development server relying on environment variables"
.IX Subsection "Development server relying on environment variables"
Previously, the development server would allow propagation of system
environment variables into the request environment, this has changed with the
adoption of Plack. You can use Plack::Middleware::ForceEnv to achieve the
same effect.
.SH "WARNINGS"
.IX Header "WARNINGS"
.SS "Actions in your application class"
.IX Subsection "Actions in your application class"
Having actions in your application class will now emit a warning at application
startup as this is deprecated. It is highly recommended that these actions are moved
into a MyApp::Controller::Root (as demonstrated by the scaffold application
generated by catalyst.pl).
.PP
This warning, also affects tests. You should move actions in your test,
creating a myTest::Controller::Root, like the following example:
.PP
.Vb 1
\&    package MyTest::Controller::Root;
\&
\&    use strict;
\&    use warnings;
\&
\&    use parent \*(AqCatalyst::Controller\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->config(namespace => \*(Aq\*(Aq);
\&
\&    sub action : Local {
\&        my ( $self, $c ) = @_;
\&        $c\->do_something;
\&    }
\&
\&    1;
.Ve
.SS "::[\s-1MVC\s0]:: naming scheme"
.IX Subsection "::[MVC]:: naming scheme"
Having packages called MyApp::[\s-1MVC\s0]::XX is deprecated and can no longer be generated
by catalyst.pl
.PP
This is still supported, but it is recommended that you rename your application
components to Model/View/Controller.
.PP
A warning will be issued at application startup if the ::[\s-1MVC\s0]:: naming scheme is
in use.
.SS "Catalyst::Base"
.IX Subsection "Catalyst::Base"
Any code using Catalyst::Base will now emit a warning; this
module will be removed in a future release.
.SS "Methods in Catalyst::Dispatcher"
.IX Subsection "Methods in Catalyst::Dispatcher"
The following methods in Catalyst::Dispatcher are implementation
details, which may change in the 5.8X release series, and therefore their use
is highly deprecated.
.IP "tree" 4
.IX Item "tree"
.PD 0
.IP "dispatch_types" 4
.IX Item "dispatch_types"
.IP "registered_dispatch_types" 4
.IX Item "registered_dispatch_types"
.IP "method_action_class" 4
.IX Item "method_action_class"
.IP "action_hash" 4
.IX Item "action_hash"
.IP "container_hash" 4
.IX Item "container_hash"
.PD
.PP
The first time one of these methods is called, a warning will be emitted:
.PP
.Vb 2
\&    Class $class is calling the deprecated method Catalyst::Dispatcher::$public_method_name,
\&    this will be removed in Catalyst 5.9
.Ve
.PP
You should \fB\s-1NEVER\s0\fR be calling any of these methods from application code.
.PP
Plugin authors and maintainers whose plugins currently call these methods
should change to using the public \s-1API,\s0 or, if you do not feel the public \s-1API\s0
adequately supports your use case, please email the development list to
discuss what \s-1API\s0 features you need so that you can be appropriately supported.
.SS "Class files with names that don't correspond to the packages they define"
.IX Subsection "Class files with names that don't correspond to the packages they define"
In this version of Catalyst, if a component is loaded from disk, but no
symbols are defined in that component's name space after it is loaded, this
warning will be issued:
.PP
.Vb 1
\&    require $class was successful but the package is not defined.
.Ve
.PP
This is to protect against confusing bugs caused by mistyping package names,
and will become a fatal error in a future version.
.PP
Please note that 'inner packages' (via Devel::InnerPackage) are still fully
supported; this warning is only issued when component file naming does not map
to \fBany\fR of the packages defined within that component.
.ie n .SS "$c\->plugin method"
.el .SS "\f(CW$c\fP\->plugin method"
.IX Subsection "$c->plugin method"
Calling the plugin method is deprecated, and calling it at run time is \fBhighly
deprecated\fR.
.PP
Instead you are recommended to use Catalyst::Model::Adaptor or similar to
compose the functionality you need outside of the main application name space.
.PP
Calling the plugin method will not be supported past Catalyst 5.81.
